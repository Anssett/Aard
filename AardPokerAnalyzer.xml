<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, October 13, 2019, 7:51 AM -->
<!-- MuClient version 5.06-pre -->

<!-- Plugin "AardPokerAnalyzer" generated by Plugin Wizard -->

<muclient>
<plugin
   name="AardPokerAnalyzer"
   author="Algaru"
   id="868e53e4b0d17887c68e0f62"
   language="Lua"
   purpose="Analyze the cards you have and help figure out what to turn in!"
   date_written="2019-10-13 07:45:18"
   requires="5.06"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Use this plugin to help build a library of your poker cards and identify hands.

Notes:
* This plugin assumes you have your cards in a single bag
* This plugin only looks at 3 hand types - royal flush, four of a 
  kind, and straight-flush (in that order). This is because these are
  the 3 most qp-efficient hands - four of a kind is more efficient than
  straight flush because it gives 8.75 qp/card instead of 8. 
* This plugin does NOT guarantee the optimal turnin hand - there's a 
  possibility of some loss. Read "cards disclaimer" for details. 
  
Commands:
* card search - search the market for cards (also shows trivia tokens)
* card bag <bag name/id> - Set the id of the bag that contains your cards
* card report <optional bag id> - Generates a report of the hands you have.
  If a bag ID is provided, remove all elevant cards from the bag they are 
  currently in, and  puts them in the new bag for easy turnin. 
  
]]> 
</description>

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Plugin help  -->

<triggers>
  <trigger
   enabled="y"
   match="^Done building card report.$"
   omit_from_output="y"
   regexp="y"
   name="done_searching"
   script="done_searching"
   sequence="100"
  >
  </trigger>
  
  <trigger
   enabled="n"
   match="^(\(\s?\d+\)\s)?\s*(\(K\)\s?)?(\(M\)|\(Magic\)\s?)?(\(G\)|\(Glow\)\s?)?(\(H\)|\(Hum\)\s?)?\s?\|[\w\d]{1,2}\[([\w]+) of ([\w]+)\][\w\d]{1,2}\| \(1\)$"
   omit_from_output="n"
   regexp="y"
   name="found_card"
   script="found_card"
   sequence="100"
  >
  </trigger>
</triggers>


<aliases>
  <alias
   script="OnHelp"
   match="AardPokerAnalyzer:help"
   enabled="y"
  >
  </alias>
  <alias
    match="^card[s]?[ ]+help[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="OnHelp"
    >
  </alias>
  <alias
    match="^card[s]?[ ]+bag[ ]+(.*)$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_bag"
    >
  </alias>
  <alias
    match="^card[s]?[ ]+bag[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_bag"
    >
  </alias>

  <alias
    match="^card[s]?[ ]+inve?n?t?o?r?y?[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_inventory"
    >
  </alias>
  
  <alias
    match="^card[s]?[ ]+repo?r?t?[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_inventory"
    >
  </alias>

  <alias
    match="^card[s]?[ ]+repo?r?t?[ ]+(.*)$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_inventory"
    >
  </alias>
  <alias
    match="^card[s]?[ ]+disc?l?a?i?m?e?r?[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_disclaimer"
    >
  </alias>
  <alias
    match="^card[s]?[ ]+search[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    send_to='10'
    >
    <send>market search trash 1 1</send>
  </alias>
</aliases>

<script>
<![CDATA[

bag = GetVariable("bag") or ""
turnin_bag = ""

card_values = 
    {   ["Two"] = 2, ["Three"] = 3, ["Four"] = 4, ["Five"] = 5,
        ["Six"] = 6, ["Seven"] = 7, ["Eight"] = 8, ["Nine"] = 9,
        ["Ten"] = 10, ["Mephit"] = 11, ["Demon"] = 12, 
        ["Elemental"] = 13, ["Ace"] = 14
    }

card_order = 
     {   "Two", "Three", "Four", "Five", "Six",
         "Seven", "Eight", "Nine", "Ten", "Mephit",
         "Demon", "Elemental", "Ace"
     }

suits = { "Air", "Earth", "Fire", "Water" }  
  
     
collection = { ["Air"] = {}, ["Earth"] = {}, ["Fire"] = {}, ["Water"] = {} }
 


function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end

function card_disclaimer ()
    print("This plugin does NOT guarantee the optimal turnin hand - there's a ")
    print("possibility of some loss.")
    print("Example: You have:")
    print("  * Two: 1 Air, 3 Fire, 3 Water (7 cards)")
    print("  * Three: 1 Air")
    print("  * Four: 1 Air")
    print("  * Five: 1 Air")
    print("  * Six: 1 Air")
    print("  The script will check for royal flush first (none)")
    print("  It will then check for four-of-a-kind. There are 7 Two cards so a ")
    print("  four-of-a-kind will be constructed using 1 Air and 3 Fire cards. ")
    print("  However, a better solution would be to use the Fire and Water cards,")
    print("  so that the Air cards can make a straight flush.")
end

function card_bag(name, line, args)
    if args[1] then
        bag = args[1]
        SetVariable("bag", bag)
        SaveState()
        Note("Set card bag to " .. bag)
    else
        if (bag == nil)
        then
            Note("Card bag is unset!")
        else
            Note("Current card bag is " .. bag)
        end
    end
end


function card_inventory(name, line, args)
    collection = { ["Air"] = {}, ["Earth"] = {}, ["Fire"] = {}, ["Water"] = {} }
    EnableTrigger("found_card", true)
    EnableTrigger("done_searching", true)
    Send("invsort level " .. bag)
    
    if (args[1] ~= nil) then
        turnin_bag = args[1]
    end
    
    SendNoEcho("echo @YDone building card report.")
end

-- function card_vaultsearch(name, line, args)
--     collection = { ["Air"] = {}, ["Earth"] = {}, ["Fire"] = {}, ["Water"] = {} }
--     EnableTrigger("found_card", true)
--     EnableTrigger("done_searching", true)
--     Send("vault filter 1 1 trash")
--     
--     if (args[1] ~= nil) then
--         turnin_bag = args[1]
--     end
--     
--     SendNoEcho("echo @YDone building card report.")
-- end


function done_searching()
    EnableTrigger("found_card", false)
    EnableTrigger("done_searching", false)  
    
    run_report()
    
    turnin_bag = ""
end


function found_card(name, line, args)
    cardcount = args[1]
    value = args[6]
    suit  = args[7]
    
    if cardcount == "" then
        cardcount = 1
    else
        cardcount = string.sub(cardcount, string.find(cardcount, "%d+"))
    end
        
    if (collection[suit][value] == nil) then
        collection[suit][value] = cardcount
    else
        collection[suit][value] = cardcount + collection[suit][value]
    end  
end


function run_report()
    ColourNote("magenta", "", "+-----------------------------------------------------------+")
    ColourNote(
      "magenta",    "", "| Card      |  ",
      "cyan",       "", "Air  ",
      "magenta",    "", "|  ",
      "#808000",    "", "Earth  ",
      "magenta",    "", "|  ",
      "red",        "", "Fire   ",
      "magenta",    "", "|  ",
      "#008080",    "", "Water  ",
      "magenta",    "", "|  ",
      "white",      "", "Total  ",
      "magenta",    "", "|")

    ColourNote("magenta", "", "+-----------------------------------------------------------+")


    for _, value in ipairs(card_order) do
        acount = get_card_count("Air", value)
        ecount = get_card_count("Earth", value)
        fcount = get_card_count("Fire", value)
        wcount = get_card_count("Water", value)
        total = acount + ecount + fcount + wcount
        
        f_acount = format_count(acount, 7)
        f_ecount = format_count(ecount, 9)
        f_fcount = format_count(fcount, 9)
        f_wcount = format_count(wcount, 9)
        f_total  = format_count( total, 9)
       
        value = string.format(" %-10s", value)
   
        ColourNote(
            "magenta",  "", "|",
            "white",    "", value,
            "magenta",  "", "|",
            "white",    "", f_acount,
            "magenta",  "", "|",
            "white",    "", f_ecount,
            "magenta",  "", "|",
            "white",    "", f_fcount,
            "magenta",  "", "|",
            "white",    "", f_wcount,
            "magenta",  "", "|",
            "white",    "", f_total,
            "magenta",  "", "|")
    end
    
    ColourNote("magenta", "", "+-----------------------------------------------------------+\n")   
    
    four_of_a_kind_count = 0;
    r_flush_count = 0;
    s_flush_count = 0;
    total_qp = 0;
    
    r_flush_count = find_royal_flush()
    four_of_a_kind_count = find_four_of_a_kind()
    s_flush_count = find_straight_flush()
    total_qp = (50 * r_flush_count) + (35 * four_of_a_kind_count) + (40 * s_flush_count)
    
    ColourNote("magenta", "", "Royal Flush hands: ", "white", "", r_flush_count)   
    ColourNote("magenta", "", "Four of a Kind hands: ", "white", "", four_of_a_kind_count) 
    ColourNote("magenta", "", "Straight Flush hands: ", "white", "", s_flush_count)     
    ColourNote("magenta", "", "Quest Points: ", "white", "", total_qp)   
end

function get_card_count(suit, value)
    count = collection[suit][value]
    if count == nil then
        count = 0
    end
    
    return tonumber(count)
end

function format_count(count, width)
    cstring = tostring(count)
    string_length = string.len(cstring)
    pad_length = math.floor((width - string_length) / 2)
    
    l_pad = build_pad(pad_length)
    r_pad = build_pad(width - ( pad_length + string_length ))
    
    return l_pad .. cstring .. r_pad    
end


function build_pad(width)
    string = ""
    if width < 0 then
        return string
    end
    
    while string.len(string) < width do
        string = string .. " "
    end
    
    return string
end


function find_royal_flush()
    royal_flush_count = 0
    
    for _, suit in ipairs(suits) do
        tcount = get_card_count(suit, "Ten")
        mcount = get_card_count(suit, "Mephit")
        dcount = get_card_count(suit, "Demon")
        ecount = get_card_count(suit, "Elemental")
        acount = get_card_count(suit, "Ace")
        
        royal_flush_suit_count = math.min(tcount, mcount, dcount, ecount, acount)
        if (royal_flush_suit_count > 0) then
            royal_flush_count = royal_flush_count + royal_flush_suit_count
            collection[suit]["Ten"] = tcount - royal_flush_suit_count
            collection[suit]["Mephit"] = mcount - royal_flush_suit_count
            collection[suit]["Demon"] = dcount - royal_flush_suit_count
            collection[suit]["Elemental"] = ecount - royal_flush_suit_count
            collection[suit]["Ace"] = acount - royal_flush_suit_count
            
            while (royal_flush_suit_count > 0 and turnin_bag ~= "" ) do
                -- elemental shows up in a bunch of different cards
                -- use "King" instead
                Send("get 'playingcard " .. suit .. " Ace' ".. "'" .. bag .. "'" )
                Send("get 'playingcard " .. suit .. " King' ".. "'" .. bag .. "'" )
                Send("get 'playingcard " .. suit .. " Demon' ".. "'" .. bag .. "'" )
                Send("get 'playingcard " .. suit .. " Mephit' ".. "'" .. bag .. "'" )
                Send("get 'playingcard " .. suit .. " Ten' ".. "'" .. bag .. "'" )
                
                Send("put all.'playingcard " .. suit .. "' ".. "'" .. turnin_bag .. "'" )
                
                royal_flush_suit_count = royal_flush_suit_count - 1
            end
        end
    end
    
    return royal_flush_count
end


function find_four_of_a_kind()
    four_of_a_kind_count = 0
    total_four_of_a_kind_count = 0
    for _, value in ipairs(card_order) do
    
        -- only check 4 of a kind if it's not 10 or a face card
        -- lua doesn't have continue?! use this ugliness..
        if card_values[value] >= 10 then
            goto endloop
        end
        
        cards_to_remove = 0
        four_of_a_kind_count = 0
        acount = get_card_count("Air", value)
        ecount = get_card_count("Earth", value)
        fcount = get_card_count("Fire", value)
        wcount = get_card_count("Water", value)
        total = acount + ecount + fcount + wcount

        four_of_a_kind_count = four_of_a_kind_count + math.floor(total / 4) 
        total_four_of_a_kind_count = total_four_of_a_kind_count + four_of_a_kind_count
        
        -- we need to remove cards from our set now.
        -- simplest way - we know how many cards to remove, just go through suits
        -- in alphabetical order and remove cards until there we have enough
        
        cards_to_remove = four_of_a_kind_count * 4
        
        for _, suit in ipairs(suits) do
            if cards_to_remove > 0 then
                suit_count = get_card_count(suit, value)
                cards_removed_from_suit = 0
                
                if (suit_count > cards_to_remove) then
                     cards_removed_from_suit = cards_to_remove
                else
                     cards_removed_from_suit = suit_count
                end
                
                cards_to_remove = cards_to_remove - cards_removed_from_suit
                collection[suit][value] = suit_count - cards_removed_from_suit
                -- print(value .. "/" .. suit .. " changed from " .. suit_count .. " to " .. get_card_count(suit, value))
                
                if (turnin_bag ~= "" and cards_removed_from_suit > 0) then
                    cards_to_put_back = get_card_count(suit, value)
                    Send("get all.'playingcard " .. suit .. " " .. value .. "' ".. "'" .. bag .. "'")
                    while (cards_to_put_back > 0) do
                        Send("put 'playingcard " .. suit .. " " .. value .. "' ".. "'" .. bag .. "'" )
                        cards_to_put_back = cards_to_put_back - 1
                    end
                    
                    Send("put all.'playingcard " .. suit .. " " .. value .. "' ".. "'" .. turnin_bag .. "'")                    
                end
            end
        end
        ::endloop::
    end
    
    return total_four_of_a_kind_count
end


function find_straight_flush()
    -- Straight flush - look within a suit, find any sequences of five cards
    -- This only checks for straights starting with 2-5. We don't want to user
    -- cards with values >= 10 because those should be saved to build royal flushes
    
    straight_flush_count = 0
    
    for _, suit in ipairs(suits) do
        for index = 1, 4 do
            value1 = card_order[index+0]
            value2 = card_order[index+1]
            value3 = card_order[index+2]
            value4 = card_order[index+3]
            value5 = card_order[index+4]
 
            count1 = get_card_count(suit, value1)
            count2 = get_card_count(suit, value2)
            count3 = get_card_count(suit, value3)
            count4 = get_card_count(suit, value4)
            count5 = get_card_count(suit, value5)
            
            while (count1 > 0 and count2 > 0 and count3 > 0 
                and count4 > 0 and count5 > 0) do
                
                collection[suit][value1] = get_card_count(suit, value1) - 1
                collection[suit][value2] = get_card_count(suit, value2) - 1
                collection[suit][value3] = get_card_count(suit, value3) - 1
                collection[suit][value4] = get_card_count(suit, value4) - 1
                collection[suit][value5] = get_card_count(suit, value5) - 1
                
                count1 = get_card_count(suit, value1)
                count2 = get_card_count(suit, value2)
                count3 = get_card_count(suit, value3)
                count4 = get_card_count(suit, value4)
                count5 = get_card_count(suit, value5)
                
                straight_flush_count = straight_flush_count + 1

                if (turnin_bag ~= "") then 
                    Send("get 'playingcard " .. suit .. " " .. value1 .. "' ".. "'" .. bag .. "'")
                    Send("get 'playingcard " .. suit .. " " .. value2 .. "' ".. "'" .. bag .. "'")
                    Send("get 'playingcard " .. suit .. " " .. value3 .. "' ".. "'" .. bag .. "'")
                    Send("get 'playingcard " .. suit .. " " .. value4 .. "' ".. "'" .. bag .. "'")
                    Send("get 'playingcard " .. suit .. " " .. value5 .. "' ".. "'" .. bag .. "'")

                    Send("put all.'playingcard " .. suit .. "' ".. "'" .. turnin_bag .. "'")                    
                end
                
            end
        
        end
        
    end
    
    return straight_flush_count
end


]]>

</script> 

</muclient>
