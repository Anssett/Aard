<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, October 13, 2019, 7:51 AM -->
<!-- MuClient version 5.06-pre -->

<!-- Plugin "AardPokerAnalyzer" generated by Plugin Wizard -->

<muclient>
<plugin
   name="AardPokerAnalyzer"
   author="Algaru"
   id="868e53e4b0d17887c68e0f62"
   language="Lua"
   purpose="Analyze the cards you have and help figure out what to turn in!"
   date_written="2019-10-13 07:45:18"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Use this plugin to help build a library of your poker cards and identify hands.

Notes:
* This plugin assumes you have your cards in a single bag
* This plugin only looks at 3 hand types - royal flush, four of a 
  kind, and straight-flush (in that order). This is because these are
  the 3 most qp-efficient hands. 
  * Royal flush:    10.0 qp/card (50 qp total, 5 cards)
  * Four-of-a-kind: 8.75 qp/card (35 qp total, 4 cards) 
  * Straight flush: 8.00 qp/card (40 qp total, 5 cards)
* Because of the relative turn-in values of these hands, this script ignores
  tens and face cards when looking at four of a kind and straight flush hands.
  These are intentionally saved to build royal flushes instead. This behavior
  can be toggled if you choose. 
* This plugin does NOT guarantee the optimal turnin hand - there's a 
  possibility of some loss. Read "cards disclaimer" for details. 
  
Commands:
* card search - search the market for cards (also shows trivia tokens)
* card bag <bag name/id> - Set the id of the bag that contains your cards
* card report <optional bag id> - Generates a report of the hands you have.
    If a bag ID is provided, remove all elevant cards from the bag they are 
    currently in, and  puts them in the new bag for easy turnin. 
* card vaultsearch <optional bag id> - Same as card report, but searches
    in a vault instead. 
* card checkface <on/off> - Toggle the behavior for checking face cards for
    four of a kind and straight flush. If no parameter is passed, it displays
    the current setting. 
* card reset - reset plugin variables to default (no bag, checkface off)
* card vars - dump the current variable values. 
  
]]> 
</description>

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Plugin help  -->

<triggers>
  <trigger
   enabled="y"
   match="^Done building card report.$"
   omit_from_output="y"
   regexp="y"
   name="done_searching"
   script="done_searching"
   sequence="100"
  >
  </trigger>
  
  <trigger
   enabled="n"
   match="^(\(\s?\d+\)\s)?\s*(\(K\)\s?)?(\(M\)|\(Magic\)\s?)?(\(G\)|\(Glow\)\s?)?(\(H\)|\(Hum\)\s?)?\s?\|[\w\d]{1,2}\[([\w]+) of ([\w]+)\][\w\d]{1,2}\| \(1\)$"
   omit_from_output="n"
   regexp="y"
   name="found_card"
   script="found_card"
   sequence="100"
  >
  </trigger>
</triggers>


<aliases>
  <alias
   script="OnHelp"
   match="AardPokerAnalyzer:help"
   enabled="y"
  >
  </alias>
  <alias
    match="^card[s]?[ ]+help[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="OnHelp"
    >
  </alias>
  <alias
    match="^card[s]?[ ]+bag[ ]+(.*)$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_bag"
    >
  </alias>
  <alias
    match="^card[s]?[ ]+bag[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_bag"
    >
  </alias>

  <alias
    match="^card[s]?[ ]+checkface[ ]+(on|off)?$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_checkface"
    >
  </alias>
  
  <alias
    match="^card[s]?[ ]+checkface[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_checkface"
    >
  </alias>  
  
  <alias
    match="^card[s]?[ ]+reset[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_reset"
    >
  </alias>  

  <alias
    match="^card[s]?[ ]+vars[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_vars"
    >
  </alias>  
  <alias
    match="^card[s]?[ ]+inve?n?t?o?r?y?[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_inventory"
    >
  </alias>
  
  <alias
    match="^card[s]?[ ]+repo?r?t?[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_inventory"
    >
  </alias>

  <alias
    match="^card[s]?[ ]+repo?r?t?[ ]+(.*)$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_inventory"
    >
  </alias>
  <alias
    match="^card[s]?[ ]+vaults?e?a?r?c?h?[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_vaultsearch"
    >
  </alias>

  <alias
    match="^card[s]?[ ]+vaults?e?a?r?c?h?[ ]+(.*)$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_vaultsearch"
    >
  </alias>
  <alias
    match="^card[s]?[ ]+disc?l?a?i?m?e?r?[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    script="card_disclaimer"
    >
  </alias>
  <alias
    match="^card[s]?[ ]+search[ ]*$"
    regexp="y"
    enabled="y"
    sequence="101"
    send_to='10'
    >
    <send>market search trash 1 1</send>
  </alias>
</aliases>

<script>
<![CDATA[

bag = GetVariable("bag") or ""
checkface = GetVariable("checkface") or "off"

-- needed? 
queue = {}

WAIT_TIME = .250

turnin_bag = ""
getcmd = "get"

card_values = 
    {   ["Two"] = 2, ["Three"] = 3, ["Four"] = 4, ["Five"] = 5,
        ["Six"] = 6, ["Seven"] = 7, ["Eight"] = 8, ["Nine"] = 9,
        ["Ten"] = 10, ["Mephit"] = 11, ["Demon"] = 12, 
        ["Elemental"] = 13, ["Ace"] = 14
    }

card_order = 
     {   "Two", "Three", "Four", "Five", "Six",
         "Seven", "Eight", "Nine", "Ten", "Mephit",
         "Demon", "Elemental", "Ace"
     }

suits = { "Air", "Earth", "Fire", "Water" }  
  
     
collection = { ["Air"] = {}, ["Earth"] = {}, ["Fire"] = {}, ["Water"] = {} }
 


function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end

function card_disclaimer ()
    print("This plugin does NOT guarantee the optimal turnin hand - there's a ")
    print("possibility of some loss.")
    print("Example: You have:")
    print("  * Two: 1 Air, 3 Fire, 3 Water (7 cards)")
    print("  * Three: 1 Air")
    print("  * Four: 1 Air")
    print("  * Five: 1 Air")
    print("  * Six: 1 Air")
    print("  The script will check for royal flush first (none)")
    print("  It will then check for four-of-a-kind. There are 7 Two cards so a ")
    print("  four-of-a-kind will be constructed using 1 Air and 3 Fire cards. ")
    print("  However, a better solution would be to use the Fire and Water cards,")
    print("  so that the Air cards can make a straight flush.")
end



function card_vars()
    Note("Dumping card plugin variables.")
    Note("Card bag: " .. GetVariable("bag"))
    Note("Check face: " .. GetVariable("checkface"))
end

function card_reset()
    Note("Resetting card bag and check facecard option to defaults.")
    SetVariable("bag", "")
    SetVariable("checkface", "off")
    queue = {}
    SaveState()
    card_vars()
end

function card_bag(name, line, args)
    if args[1] then
        _bag = args[1]
        SetVariable("bag", _bag)
        SaveState()
        Note("Set card bag to " .. GetVariable("bag"))
    else
        _bag = GetVariable("bag") 
        if (_bag == nil or bag == "")
        then
            Note("Card bag is unset!")
        else
            Note("Current card bag is " .. _bag)
        end
    end
end

function card_checkface(name, line, args)
    if args[1] then
        _checkface = args[1]
        SetVariable("checkface", _checkface)
        SaveState()
        Note("Set card checkface to " .. GetVariable("checkface"))
    else
        _checkface = GetVariable("checkface") 
        if (_checkface == nil or checkface == "")
        then
            Note("Card checkface is unset! Default behavior is off.")
        else
            Note("Current card checkface is " .. _checkface)
        end
    end
end


function card_inventory(name, line, args)
    collection = { ["Air"] = {}, ["Earth"] = {}, ["Fire"] = {}, ["Water"] = {} }
    queue = {}
    getcmd = "get"
    bag = GetVariable("bag") or ""
    checkface = GetVariable("checkface") or ""

    EnableTrigger("found_card", true)
    EnableTrigger("done_searching", true)
    Send("invsort level " .. bag)
    
    if (args[1] ~= nil) then
        turnin_bag = args[1]
    end
    
    SendNoEcho("echo @YDone building card report.")
end

function card_vaultsearch(name, line, args)
    collection = { ["Air"] = {}, ["Earth"] = {}, ["Fire"] = {}, ["Water"] = {} }
    queue = {}
    getcmd = "vault get"
    bag = ""
    EnableTrigger("found_card", true)
    EnableTrigger("done_searching", true)
    Send("vault filter 1 1 trash")
    
    if (args[1] ~= nil) then
        turnin_bag = args[1]
    end
    
    SendNoEcho("echo @YDone building card report.")
    bag = GetVariable("bag") or ""
    checkface = GetVariable("checkface") or ""
end


function done_searching()
    EnableTrigger("found_card", false)
    EnableTrigger("done_searching", false)  
    
    run_report()
    
    turnin_bag = ""
end


function found_card(name, line, args)
    cardcount = args[1]
    value = args[6]
    suit  = args[7]
    
    if cardcount == "" then
        cardcount = 1
    else
        cardcount = string.sub(cardcount, string.find(cardcount, "%d+"))
    end
        
    if (collection[suit][value] == nil) then
        collection[suit][value] = cardcount
    else
        collection[suit][value] = cardcount + collection[suit][value]
    end  
end


function run_report()
    ColourNote("magenta", "", "+-----------------------------------------------------------+")
    ColourNote(
      "magenta",    "", "| Card      |  ",
      "cyan",       "", "Air  ",
      "magenta",    "", "|  ",
      "#808000",    "", "Earth  ",
      "magenta",    "", "|  ",
      "red",        "", "Fire   ",
      "magenta",    "", "|  ",
      "#008080",    "", "Water  ",
      "magenta",    "", "|  ",
      "white",      "", "Total  ",
      "magenta",    "", "|")

    ColourNote("magenta", "", "+-----------------------------------------------------------+")

    for _, value in ipairs(card_order) do
        acount = get_card_count("Air", value)
        ecount = get_card_count("Earth", value)
        fcount = get_card_count("Fire", value)
        wcount = get_card_count("Water", value)
        total = acount + ecount + fcount + wcount
        
        f_acount = center_string(acount, 7)
        f_ecount = center_string(ecount, 9)
        f_fcount = center_string(fcount, 9)
        f_wcount = center_string(wcount, 9)
        f_total  = center_string( total, 9)
       
        value = string.format(" %-10s", value)
   
        ColourNote(
            "magenta",  "", "|",
            "white",    "", value,
            "magenta",  "", "|",
            "white",    "", f_acount,
            "magenta",  "", "|",
            "white",    "", f_ecount,
            "magenta",  "", "|",
            "white",    "", f_fcount,
            "magenta",  "", "|",
            "white",    "", f_wcount,
            "magenta",  "", "|",
            "white",    "", f_total,
            "magenta",  "", "|")
    end
    
    ColourNote("magenta", "", "+-----------------------------------------------------------+\n")   
    
    checkstring = "*** Check Face Cards option is currently " .. checkface .. ". ***"
    
    ColourNote("white", "", center_string(checkstring, 62) .. "\n")
    four_of_a_kind_count = 0;
    r_flush_count = 0;
    s_flush_count = 0;
    total_qp = 0;
    
    r_flush_count = find_royal_flush()
    four_of_a_kind_count = find_four_of_a_kind()
    s_flush_count = find_straight_flush()
    total_qp = (50 * r_flush_count) + (35 * four_of_a_kind_count) + (40 * s_flush_count)
    
    ColourNote("magenta", "", "Royal Flush hands: ", "white", "", r_flush_count)   
    ColourNote("magenta", "", "Four of a Kind hands: ", "white", "", four_of_a_kind_count) 
    ColourNote("magenta", "", "Straight Flush hands: ", "white", "", s_flush_count)     
    ColourNote("magenta", "", "Quest Points: ", "white", "", total_qp)   
    
    process_queue()
end

function get_card_count(suit, value)
    count = collection[suit][value]
    if count == nil then
        count = 0
    end
    
    return tonumber(count)
end

function center_string(input, width)
    cstring = tostring(input)
    string_length = string.len(cstring)
    pad_length = math.floor((width - string_length) / 2)
    
    l_pad = build_pad(pad_length)
    r_pad = build_pad(width - ( pad_length + string_length ))
    
    return l_pad .. cstring .. r_pad    
end


function build_pad(width)
    string = ""
    if width < 0 then
        return string
    end
    
    while string.len(string) < width do
        string = string .. " "
    end
    
    return string
end


function find_royal_flush()
    royal_flush_count = 0
        
    for _, suit in ipairs(suits) do
        tcount = get_card_count(suit, "Ten")
        mcount = get_card_count(suit, "Mephit")
        dcount = get_card_count(suit, "Demon")
        ecount = get_card_count(suit, "Elemental")
        acount = get_card_count(suit, "Ace")
        
        royal_flush_suit_count = math.min(tcount, mcount, dcount, ecount, acount)
        if (royal_flush_suit_count > 0) then
            royal_flush_count = royal_flush_count + royal_flush_suit_count
            collection[suit]["Ten"] = tcount - royal_flush_suit_count
            collection[suit]["Mephit"] = mcount - royal_flush_suit_count
            collection[suit]["Demon"] = dcount - royal_flush_suit_count
            collection[suit]["Elemental"] = ecount - royal_flush_suit_count
            collection[suit]["Ace"] = acount - royal_flush_suit_count
            
            while (royal_flush_suit_count > 0 and turnin_bag ~= "" ) do
                -- elemental shows up in a bunch of different cards
                -- use "King" instead

                -- local copy because wait.time seems to clear the value of turnin_bag otherwise
                local_turnin = turnin_bag
                table.insert(queue, getcmd .. " 'playingcard " .. suit .. " Ace' ".. "'" .. bag .. "'" )
                table.insert(queue, getcmd .. " 'playingcard " .. suit .. " King' ".. "'" .. bag .. "'" )
                table.insert(queue, getcmd .. " 'playingcard " .. suit .. " Demon' ".. "'" .. bag .. "'" )
                table.insert(queue, getcmd .. " 'playingcard " .. suit .. " Mephit' ".. "'" .. bag .. "'" )
                table.insert(queue, getcmd .. " 'playingcard " .. suit .. " Ten' ".. "'" .. bag .. "'" )
                table.insert(queue, "put all.'playingcard " .. suit .. "' ".. "'" .. local_turnin .. "'" )
                
                royal_flush_suit_count = royal_flush_suit_count - 1
            end
        end
    end
        
    return royal_flush_count
end


function find_four_of_a_kind()
    four_of_a_kind_count = 0
    total_four_of_a_kind_count = 0
    for _, value in ipairs(card_order) do
        
        cards_found = false
        
        -- only check 4 of a kind if it's not 10 or a face card
        -- lua doesn't have continue?! use this ugliness..
        if card_values[value] >= 10 and checkface ~= "on" then
            goto endloop
        end
        
        cards_to_remove = 0
        four_of_a_kind_count = 0
        acount = get_card_count("Air", value)
        ecount = get_card_count("Earth", value)
        fcount = get_card_count("Fire", value)
        wcount = get_card_count("Water", value)
        total = acount + ecount + fcount + wcount

        four_of_a_kind_count = four_of_a_kind_count + math.floor(total / 4) 
        total_four_of_a_kind_count = total_four_of_a_kind_count + four_of_a_kind_count
        
        -- we need to remove cards from our set now.
        -- simplest way - we know how many cards to remove, just go through suits
        -- in alphabetical order and remove cards until there we have enough
        
        cards_to_remove = four_of_a_kind_count * 4
     
        local_turnin = turnin_bag
        for _, suit in ipairs(suits) do
            if cards_to_remove > 0 then
                suit_count = get_card_count(suit, value)
                cards_removed_from_suit = 0
                
                if (suit_count > cards_to_remove) then
                     cards_removed_from_suit = cards_to_remove
                else
                     cards_removed_from_suit = suit_count
                end
                
                cards_to_remove = cards_to_remove - cards_removed_from_suit
                collection[suit][value] = suit_count - cards_removed_from_suit
                
                if (turnin_bag ~= "" and cards_removed_from_suit > 0) then
                    cards_found = true
                    cards_to_put_back = get_card_count(suit, value)
                    table.insert(queue, getcmd .. " all.'playingcard " .. suit .. " " .. value .. "' ".. "'" .. bag .. "'")
                    while (cards_to_put_back > 0) do
                        table.insert(queue, "put 'playingcard " .. suit .. " " .. value .. "' ".. "'" .. bag .. "'" )
                        cards_to_put_back = cards_to_put_back - 1
                    end
                end
            end
        end
        
        if (cards_found) then
            table.insert(queue, "put all.'playingcard " .. value .. "' ".. "'" .. local_turnin .. "'")    
        end
        
        ::endloop::
    end
    
    return total_four_of_a_kind_count
end


function find_straight_flush()
    -- Straight flush - look within a suit, find any sequences of five cards
    
    straight_flush_count = 0
    
    -- Starting card for straight flush. 
    -- If the "check face" option is on, look for straights starting up to 9.
    -- Can skip 10 because that's a royal flush and already checked. 
    -- If it's off (default) then only go up to straights starting with 5 so
    -- we don't pull tens and face cards into the straight flush. 
    -- Maxindex is off by card value by 1 because first card is two.
    
    if (checkface == "on") then
        maxindex = 8
    else
        maxindex = 4
    end
    
    for _, suit in ipairs(suits) do
        for index = 1, maxindex do
            value1 = card_order[index+0]
            value2 = card_order[index+1]
            value3 = card_order[index+2]
            value4 = card_order[index+3]
            value5 = card_order[index+4]
 
            count1 = get_card_count(suit, value1)
            count2 = get_card_count(suit, value2)
            count3 = get_card_count(suit, value3)
            count4 = get_card_count(suit, value4)
            count5 = get_card_count(suit, value5)
            
            while (count1 > 0 and count2 > 0 and count3 > 0 
                and count4 > 0 and count5 > 0) do
                process_straight_flush(suit, value1, value2, value3, value4, value5)
            end
        end
        
        -- special handling for straight flush starting with ace
        if (checkface == "on") then
            value1 = card_order[13]   -- Ace
            value2 = card_order[1]  -- Two
            value3 = card_order[2]  -- Three
            value4 = card_order[3]  -- Four
            value5 = card_order[4]  -- Five
            
            count1 = get_card_count(suit, value1)
            count2 = get_card_count(suit, value2)
            count3 = get_card_count(suit, value3)
            count4 = get_card_count(suit, value4)
            count5 = get_card_count(suit, value5)
            
            while (count1 > 0 and count2 > 0 and count3 > 0 
                and count4 > 0 and count5 > 0) do
                process_straight_flush(suit, value1, value2, value3, value4, value5)
            end
        
        end
        
    end
    
    return straight_flush_count
end


-- helper function to process straight flush
function process_straight_flush (suit, value1, value2, value3, value4, value5)            
    collection[suit][value1] = get_card_count(suit, value1) - 1
    collection[suit][value2] = get_card_count(suit, value2) - 1
    collection[suit][value3] = get_card_count(suit, value3) - 1
    collection[suit][value4] = get_card_count(suit, value4) - 1
    collection[suit][value5] = get_card_count(suit, value5) - 1
    
    count1 = get_card_count(suit, value1)
    count2 = get_card_count(suit, value2)
    count3 = get_card_count(suit, value3)
    count4 = get_card_count(suit, value4)
    count5 = get_card_count(suit, value5)
    
    straight_flush_count = straight_flush_count + 1

    if (turnin_bag ~= "") then 
        -- local copy because wait.time seems to clear the value of turnin_bag otherwise
        local_turnin = turnin_bag
        table.insert(queue, getcmd .. " 'playingcard " .. suit .. " " .. value1 .. "' ".. "'" .. bag .. "'")
        table.insert(queue, getcmd .. " 'playingcard " .. suit .. " " .. value2 .. "' ".. "'" .. bag .. "'")
        table.insert(queue, getcmd .. " 'playingcard " .. suit .. " " .. value3 .. "' ".. "'" .. bag .. "'")
        table.insert(queue, getcmd .. " 'playingcard " .. suit .. " " .. value4 .. "' ".. "'" .. bag .. "'")
        table.insert(queue, getcmd .. " 'playingcard " .. suit .. " " .. value5 .. "' ".. "'" .. bag .. "'")
        table.insert(queue, "put all.'playingcard " .. suit .. "' ".. "'" .. local_turnin .. "'") 
    end
end


function process_queue () 
    require "wait"
    wait.make (function ()
        for _, command in ipairs(queue) do
            -- Note(command)
            Send(command)
            wait.time(WAIT_TIME)
        end
    
    end)
end


]]>

</script> 

</muclient>
